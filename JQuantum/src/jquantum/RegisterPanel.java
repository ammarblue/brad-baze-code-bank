/*
 * RegisterPanel.java - displays the quantum register in the jQuantum computer simulator
 *
 * Copyright (C) 2004-2008 Andreas de Vries
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see http://www.gnu.org/licenses
 * or write to the Free Software Foundation,Inc., 51 Franklin Street,
 * Fifth Floor, Boston, MA 02110-1301  USA
 */

package jquantum;

import java.awt.Graphics;
import org.mathIT.quantum.Register;
import static java.lang.Math.*;
import static org.mathIT.quantum.Register.*;

/**
 * With this class a panel can be created which displays the states of a quantum
 * register. A state of a quantum register with <i>n</i> &gt; 0 qubits is a
 * complex unit vector of dimension 2<sup><i>n</i></sup>, i.e., consists of
 * 2<sup><i>n</i></sup> complex numbers whose squared absolute values sum up to
 * 1 exactly. In this panel class, each complex number <i>z</i> &#8712; <span
 * style="font-size:large;">&#8450;</span> is uniquely represented by a color
 * and a brightness. For more details, see <a
 * href="http://jquantum.sourceforge.net/jQuantum.pdf"
 * >http://jquantum.sourceforge.net/jQuantum.pdf</a>.
 * <p>
 * Some special cases are to be mentioned: If the register to display is null
 * then a mesh with white squares is plotted, if it has only one entry then it
 * is not displayed at all, i.e., the panel remains completely white. This
 * latter case in fact is not possible (it refers to the case of a register
 * consisting of zero qubits), but in the jQuantum simulator it refers to a
 * nonexisting y-register which for technical reasons cannot be null.
 * 
 * @author Andreas de Vries
 * @version 1.5
 */
public class RegisterPanel extends javax.swing.JPanel {
	private static final long serialVersionUID = -605370111;
	private int width;

	private Register register;
	/** Shall the length of a qubit vector determine its color? */
	private boolean lengthBrightening;
	/** number of rows of the register state panel. */
	private int rows = 16;
	/** number of columns of the register state panel. */
	private int cols = 64;
	/** Unit width of each painted square, representing a vector component. */
	private int deltaUnit = 12;
	/** Scale to display the register states. */
	private double scale = 1.0;
	/** Flag if the scale is to be computed automatically or set manually. */
	private boolean autoScale = true;
	/** Delta between two ticks on the horizontal x-axis. Must be a power of 2. */
	private int xDelta = 8;
	/** Delta between two ticks on the horizontal y-axis. Must be a power of 2. */
	private int yDelta = 8;
	/** Font size of the ticks. */
	private int fontSize = 10;
	/** Distance of the register from the left side of this panel. */
	private int leftBorder;
	/**
	 * Flag to indicate first invocation of the paint method. The first run need
	 * not to display the register.
	 */
	private boolean firstPaint;
	/**
	 * Symbol for right angle bracket \u232A. For Windows<and Linux systems,
	 * this Unicode symbol is not available to date.
	 */
	private char rangle;

	/** Creates new RegisterPanel. */
	public RegisterPanel() {
		this.width = 800;
		this.firstPaint = true;
		this.leftBorder = 20;
		String os = System.getProperty("os.name");
		if ((os.length() >= 7 && os.substring(0, 7).equalsIgnoreCase("Windows"))
				|| (os.length() >= 5 && os.substring(0, 5).equalsIgnoreCase(
						"linux"))) {
			rangle = '>';
		} else {
			rangle = '\u232A';
		}
		initComponents();
	}

	/**
	 * Creates new RegisterPanel with specified width.
	 * 
	 * @param width
	 *            the width of this panel
	 */
	public RegisterPanel(int width) {
		this.leftBorder = 20;
		this.firstPaint = true;
		this.width = width;
		String os = System.getProperty("os.name");
		if ((os.length() >= 7 && os.substring(0, 7).equalsIgnoreCase("Windows"))
				|| (os.length() >= 5 && os.substring(0, 5).equalsIgnoreCase(
						"linux"))) {
			rangle = '>';
		} else {
			rangle = '\u232A';
		}
		initComponents();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
			@Override
			public void mouseMoved(java.awt.event.MouseEvent evt) {
				formMouseMoved(evt);
			}
		});
	}// </editor-fold>//GEN-END:initComponents

	private void formMouseMoved(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_formMouseMoved
		int x = (int) ((evt.getX() - leftBorder) / (scale * deltaUnit));
		x += cols * (int) ((evt.getY() - fontSize - 12) / (scale * deltaUnit));
		if (register != null && x >= 0 && x < (1 << register.getSize())) {
			setToolTipText("|"
					+ x
					+ rangle
					+ " = |"
					+ org.mathIT.numbers.Numbers
							.decToBin(x, register.getSize()) + rangle);
		}
	}// GEN-LAST:event_formMouseMoved

	// Variables declaration - do not modify//GEN-BEGIN:variables
	// End of variables declaration//GEN-END:variables

	/**
	 * Sets the distance of the displayed register from the left side of this
	 * panel.
	 * 
	 * @return distance of the displayed register from the left side of this
	 *         panel in pixel
	 */
	public int getLeftBorder() {
		computeParameters();
		return leftBorder;
	}

	/**
	 * Sets the flag whether the length of a qubit state vector is encoded by
	 * its brightness.
	 * 
	 * @param lengthBrightening
	 *            flag whether brightness depends on state vector length
	 */
	public void setLengthBrightening(boolean lengthBrightening) {
		this.lengthBrightening = lengthBrightening;
		repaint();
	}

	/**
	 * Sets the current qubit states of the register which is displayed by this
	 * panel.
	 * 
	 * @param register
	 *            a register
	 * @return <code>true</code> when finished
	 */
	public boolean setQubitStates(Register register) {
		this.register = register;
		this.leftBorder = 20;
		repaint();
		return true;
	}

	/**
	 * Sets the current qubit states of the register which is displayed by this
	 * panel.
	 * 
	 * @param register
	 *            a register
	 * @param leftBorder
	 *            distance of the displayed register from the left side of this
	 *            panel in pixel
	 * @return <code>true</code> when finished
	 */
	public boolean setQubitStates(Register register, int leftBorder) {
		this.register = register;
		this.leftBorder = leftBorder;
		repaint();
		return true;
	}

	/**
	 * Gets the scale which determines the size of a square representing a
	 * single qubit state vector.
	 * 
	 * @return scale the scale determining the size of the displayed quantum
	 *         register
	 */
	public double getScale() {
		computeParameters();
		return scale;
	}

	/**
	 * Sets the scale which determines the size of a square representing a
	 * single qubit state vector. If this method is not invoked, the scale is
	 * computed automatically.
	 * 
	 * @param scale
	 *            the scale determining the size of the displayed quantum
	 *            register
	 */
	public void setScale(double scale) {
		this.scale = scale;
		this.autoScale = false;
	}

	/**
	 * Compute the parameters of this panel, e.g., the number of rows and
	 * columns, or the scale.
	 */
	private void computeParameters() {
		if (register == null) {
			rows = 16;
			cols = 64;
			xDelta = 8;
			yDelta = 8;
			if (autoScale)
				scale = 1;
			return;
		} else if (register.getSize() == 0) {
			rows = -1; // do not draw x-grid
			cols = -1; // do not draw y-grid
			xDelta = 8;
			yDelta = 8;
			if (autoScale)
				scale = 1;
			return;
		}

		int length = (1 << register.getSize());
		if (length <= 1) {
			rows = 1;
			cols = 2;
			xDelta = 8;
			yDelta = 8;
			if (autoScale)
				scale = 1;
		} else if (length < 16) {
			rows = 1;
			cols = length % 64;
			xDelta = 8;
			yDelta = 4;
			if (autoScale)
				scale = 4;
		} else if (length < 64) {
			rows = 1;
			cols = length % 64;
			xDelta = 8;
			yDelta = 8;
			if (autoScale)
				scale = 2;
		} else if (length <= 1024) { // = 2^{10}
			cols = 64;
			rows = length / cols; // works only if length is a power of 2!
									// Otherwise: + 1
			xDelta = 8;
			yDelta = 8;
			if (autoScale)
				scale = 1;
		} else if (length <= 8192) { // = 2^{13}
			cols = 128;
			rows = length / cols; // works only if length is a power of 2!
									// Otherwise: + 1
			xDelta = 32;
			yDelta = 8;
			if (autoScale)
				scale = 1;
		} else if (length <= 32768) { // = 2^{15}
			cols = 256;
			rows = length / cols; // works only if length is a power of 2!
									// Otherwise: + 1
			xDelta = 64;
			yDelta = 8;
			if (autoScale)
				scale = .5;
		} else if (length <= 131072) { // = 2^{17}
			cols = 512;
			rows = length / cols; // works only if length is a power of 2!
									// Otherwise: + 1
			xDelta = 64;
			yDelta = 8;
			if (autoScale)
				scale = .25;
		} else if (length <= 262144) { // = 2^{18}
			cols = 1024;
			rows = length / cols; // works only if length is a power of 2!
									// Otherwise: + 1
			xDelta = 128;
			yDelta = 8;
			if (autoScale)
				scale = .25;
		} else { // >= 2^{19}
			cols = 2048;
			rows = length / cols; // works only if length is a power of 2!
									// Otherwise: + 1
			xDelta = 128;
			yDelta = 8;
			if (autoScale)
				scale = .25;
		}
		int xMin = ((int) log10(rows * cols) - 1) * fontSize + 5;
		if (xMin < leftBorder) {
			xMin = leftBorder;
		} else {
			leftBorder = xMin;
		}
	}

	/**
	 * Paints this register panel.
	 * 
	 * @param g
	 *            the specified Graphics window
	 */
	@Override
	public void paint(Graphics g) {
		computeParameters();
		int delta = (int) (scale * deltaUnit);

		int xMin = leftBorder;
		int yMin = fontSize + 10;
		int xMax = cols * delta + xMin;
		int yMax = rows * delta + yMin;
		// firstPaint |= (width != xMax + 1); // in case of first run or
		// resizing ...
		width = xMax + 1;
		int height = yMax + 10;
		setPreferredSize(new java.awt.Dimension(width, height));
		super.paint(g); // necessary to repaint correctly after scrolling
		revalidate(); // notify scroll pane about size change, if necessary

		if (firstPaint) {
			firstPaint = false;
			return;
		}

		g.setColor(new java.awt.Color(80, 80, 80)); // color of ticks and mesh
		g.setFont(new java.awt.Font("Helvetica", java.awt.Font.PLAIN, fontSize)); // ticks
																					// font

		// x-ticks:
		for (int i = xDelta; i < cols; i += xDelta) {
			g.drawString("" + i, xMin + i * delta, fontSize + 9);
		}
		// y-ticks:
		String str;
		for (int j = 0; j < rows; j += yDelta) {
			str = "" + j * cols;
			// text-align right:
			g.drawString(str,
					xMin
							- (int) g.getFontMetrics().getStringBounds(str, g)
									.getWidth() - 1, j * delta + delta / 2
							+ yMin + fontSize / 2);
		}

		// draw horizontal lines of register state mesh:
		for (int j = 0; j <= rows; j++) {
			g.drawLine(xMin, yMin + j * delta, xMin + cols * delta, yMin + j
					* delta); // horizontal lines
		}
		// draw vertical lines of register state mesh:
		for (int i = 0; i <= cols; i++) {
			g.drawLine(xMin + i * delta, yMin, xMin + i * delta, yMin + rows
					* delta); // vertical lines
		}

		if (register != null && register.getSize() > 0) { // length >= 2) {
			int numberOfStates = (1 << register.getSize());
			double[] real = register.getReal();
			double[] imaginary = register.getImaginary();

			for (int j = 0; j < numberOfStates; j++) {
				int row = j / cols;
				int column = j % cols;

				int x = delta * column;
				int y = delta * row;

				double phase;

				// determine the color in dependence of the phase of the j-th
				// complex vector component:
				if (real[j] == 0) {
					phase = PI / 2;
					if (imaginary[j] < 0) {
						phase = 2 * PI - phase;
					}
				} else {
					phase = atan(imaginary[j] / real[j]);
					if (real[j] < 0) {
						phase += PI;
					} else if (imaginary[j] < 0) {
						phase += 2 * PI;
					}
				}
				phase /= 2 * PI;

				if (abs(real[j]) < ACCURACY && abs(imaginary[j]) < ACCURACY) {
					g.setColor(new java.awt.Color(0f, 0f, 0f));
				} else {
					if (lengthBrightening) { // length brightening to encode the
												// vector uniquely?
						float length = (float) sqrt(real[j] * real[j]
								+ imaginary[j] * imaginary[j]);
						g.setColor(java.awt.Color.getHSBColor((float) phase,
								1f, (float) pow(length, .25)));
					} else {
						g.setColor(java.awt.Color.getHSBColor((float) phase,
								1f, 1f));
					}
				}
				g.fillRect(xMin + x + 1, yMin + y + 1, delta - 1, delta - 1);
			}
		}
	}

	/** For testing... */
	/*
	 * public static void main(String[] args) { int width = 800, height = 224;
	 * int size = 0;
	 * 
	 * //double[] real = new double[0]; //double[] imaginary = new double[0];
	 * double[] real = new double[1<<size]; double[] imaginary = new double[1<<
	 * size]; real[2] = 1.; real[4]=sqrt(.5); imaginary[4]=sqrt(.5);
	 * imaginary[1] = 1.0; Register register = new Register(size);
	 * register.setReal(real); register.setImaginary(imaginary);
	 * 
	 * RegisterPanel rp = new RegisterPanel(width); rp.setQubitStates(register);
	 * 
	 * javax.swing.JScrollPane scrollPane = new javax.swing.JScrollPane(rp);
	 * javax.swing.JFrame fenster = new javax.swing.JFrame("Quantum Register");
	 * fenster.getContentPane().add(scrollPane); scrollPane.setPreferredSize(new
	 * java.awt.Dimension(width,height));
	 * fenster.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);
	 * fenster.pack(); fenster.setVisible(true); } //
	 */
}

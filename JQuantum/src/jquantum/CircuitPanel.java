/*
 * CircuitPanel.java - Class of the jQuantum computer simulator
 *
 * Copyright (C) 2004-2008 Andreas de Vries
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see http://www.gnu.org/licenses
 * or write to the Free Software Foundation,Inc., 51 Franklin Street,
 * Fifth Floor, Boston, MA 02110-1301  USA
 */

package jquantum;

import java.awt.Color;
import java.awt.Graphics;
import org.mathIT.quantum.QuantumGate;
import org.mathIT.quantum.Circuit;

/**
 * This class serves to show the panel on which the quantum circuits are
 * displayed.
 * 
 * @author Andreas de Vries
 * @version 1.6
 */
public class CircuitPanel extends javax.swing.JPanel {
	private static final long serialVersionUID = 727054267;
	/** The circuit of of quantum gates which is displayed. */
	private Circuit circuit;
	/** The circuit of of quantum gates which is displayed. */
	private java.util.Properties bundle;

	/**
	 * Creates new CircuitPanel.
	 * 
	 * @param circuit
	 *            the quantum circuit to be displayed
	 */
	public CircuitPanel(Circuit circuit) {
		this.circuit = circuit;
		initComponents();
	}

	/**
	 * Sets the properties bundle for this circuit panel.
	 * 
	 * @param bundle
	 *            the properties bundle to display messages
	 */
	public void setBundle(java.util.Properties bundle) {
		this.bundle = bundle;
	}

	/**
	 * This method is called from within the constructor to initialize this
	 * circuit panel. Note, however, that this class has no GUI components.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	private void initComponents() {// GEN-BEGIN:initComponents

	}// GEN-END:initComponents

	/**
	 * Paints and repaints the circuit panel.
	 * 
	 * @param g
	 *            the Graphic object
	 */
	@Override
	public void paint(Graphics g) {
		super.paint(g);
		int numberOfWires = circuit.getNumberOfWires();
		if (numberOfWires > 0) {
			int fontSize = 10;
			int xDelta = 30; // stepwidth of each gate
			int yDelta = (getHeight() - 3) / numberOfWires;
			int x = 0, y, y0 = 0, y1 = 0, y2 = 0;
			int adjust = 2; // constant number of pixels to adjust the height of
							// wires and gates

			// adapt width of this panel because of scroll pane:
			setPreferredSize(new java.awt.Dimension((circuit.size() + 1)
					* xDelta, getHeight()));
			revalidate(); // notify the scroll pane (if any)!

			g.setFont(new java.awt.Font("Helvetica", java.awt.Font.PLAIN,
					fontSize));
			int fontHeight = g.getFontMetrics().getHeight();

			int currentGate = circuit.getNextGateNumber();
			int xRegisterSize = circuit.getXRegisterSize();
			int yRegisterSize = circuit.getYRegisterSize();

			// mark current gate position during a quantum circuit execution:
			if (currentGate > 0 && currentGate <= circuit.size()) {
				x = (5 * (currentGate + 1) - 1) * xDelta / 5;
				g.setColor(new java.awt.Color(0, 128, 0));
				g.drawLine(x, 1, x, getHeight() - 1);
				g.setColor(java.awt.Color.black);
			}

			// The gap between the two registers:
			int gap = 5;

			// The radius of dots and cycles:
			int radius;

			// draw tips of the wires:
			for (int i = 0; i < xRegisterSize; i++) {
				y = (2 * i + 1) * yDelta / 2 + adjust;
				g.drawLine(0, y, xDelta, y);
			}
			for (int i = 0; i < yRegisterSize; i++) {
				y = (2 * i + 1) * yDelta / 2 + gap + xRegisterSize * yDelta
						+ adjust;
				g.drawLine(0, y, xDelta, y);
			}

			// ticks for the wires:
			g.setColor(new java.awt.Color(127, 127, 127));
			for (int i = 0; i < xRegisterSize; i++) {
				g.drawString("" + (xRegisterSize - i), 0, (2 * i + 1) * yDelta
						/ 2 + adjust);
			}
			for (int i = 0; i < yRegisterSize; i++) {
				g.drawString("" + (yRegisterSize - i), 0, (2 * i + 1) * yDelta
						/ 2 + gap + xRegisterSize * yDelta + adjust);
			}
			g.setColor(java.awt.Color.black);

			QuantumGate gate; // stores the next gate in each iteration

			for (int i = 0; i < circuit.size(); i++) {
				gate = circuit.get(i);

				// draw wires:
				for (int il = 0; il < numberOfWires; il++) {
					y = (2 * (numberOfWires - il) - 1) * yDelta / 2 + adjust;
					if (il < yRegisterSize)
						y += gap;
					g.drawLine((i + 1) * xDelta, y, (i + 2) * xDelta, y);
				}

				int max = 0, min = 0;
				if (gate.qubits.length > 0
						&& !gate.name.equalsIgnoreCase("Grover")) {
					max = Integer.MIN_VALUE;
					min = Integer.MAX_VALUE;
					for (int j = 0; j < gate.qubits.length; j++) {
						if (max < gate.qubits[j])
							max = gate.qubits[j];
						if (min > gate.qubits[j])
							min = gate.qubits[j];
					}
				}

				int gateHeight = (max - min + 1) * yDelta;
				if (gate.name.equalsIgnoreCase("initialState")) {
					g.setColor(Color.white);
					g.fillRect(xDelta / 2 - 5, 1, xDelta + 5, getHeight() - 3);
					g.setColor(Color.black);

					for (int k = 0; k < gate.qubits.length; k++) {
						y = (2 * k + 1) * yDelta / 2 + 4 + adjust;
						if (k >= xRegisterSize)
							y += gap;
						g.drawString("|" + gate.qubits[k] + ">", xDelta - 10, y);
					}
				} else if (gate.name.equalsIgnoreCase("Hadamard")) {
					gateHeight = 12;
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						max += yRegisterSize;
						min += yRegisterSize;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					g.setColor(Color.black);
					g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.drawString("H", x, y0 + 4);
				} else if (gate.name.equalsIgnoreCase("cNOT")) {
					radius = numberOfWires <= 5 ? 3 : 2;
					x = (4 * i + 5) * xDelta / 4;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
						y1 = (2 * (numberOfWires - gate.qubits[1]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						y1 = (2 * (xRegisterSize - gate.qubits[1]) + 1)
								* yDelta / 2 + adjust;
					}
					g.fillOval(x - radius, y0 - radius, 2 * radius, 2 * radius);
					radius = numberOfWires <= 5 ? 6 : 4;
					if (y0 < y1) {
						g.drawLine(x, y0, x, y1 + radius);
					} else {
						g.drawLine(x, y0, x, y1 - radius);
					}
					g.drawOval(x - radius, y1 - radius, 2 * radius, 2 * radius);
				} else if (gate.name.equalsIgnoreCase("Pauli-X")) {
					gateHeight = 12;
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						max += yRegisterSize;
						min += yRegisterSize;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					g.setColor(Color.black);
					g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.drawString("X", x, y0 + 4);
				} else if (gate.name.equalsIgnoreCase("Pauli-Y")) {
					gateHeight = 12;
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						max += yRegisterSize;
						min += yRegisterSize;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					g.setColor(Color.black);
					g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.drawString("Y", x, y0 + 4);
				} else if (gate.name.equalsIgnoreCase("Pauli-Z")) {
					gateHeight = 12;
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						max += yRegisterSize;
						min += yRegisterSize;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					g.setColor(Color.black);
					g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.drawString("Z", x, y0 + 4);
				} else if (gate.name.equalsIgnoreCase("S")) {
					gateHeight = 12;
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						max += yRegisterSize;
						min += yRegisterSize;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					g.setColor(Color.black);
					g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.drawString("S", x, y0 + 4);
				} else if (gate.name.equalsIgnoreCase("invS")) {
					gateHeight = 12;
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						max += yRegisterSize;
						min += yRegisterSize;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					g.setColor(Color.black);
					g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.drawString("S", x - 2, y0 + 4);
					x += fontSize - 3;
					y0 += 2 + fontSize / 5 - gateHeight / 2;
					g.drawLine(x, y0 - fontSize / 5, x, y0 + fontSize / 3);
					g.drawLine(x - 2, y0, x + 2, y0);
				} else if (gate.name.equalsIgnoreCase("T")) {
					gateHeight = 12;
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						max += yRegisterSize;
						min += yRegisterSize;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					g.setColor(Color.black);
					g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.drawString("T", x, y0 + 4);
				} else if (gate.name.equalsIgnoreCase("sqrt-X")) {
					gateHeight = 12;
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						max += yRegisterSize;
						min += yRegisterSize;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					g.setColor(Color.black);
					g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
					x = (4 * i + 5) * xDelta / 4 - fontHeight / 2;
					g.drawString("\u221AX", x, y0 + 4);
				} else if (gate.name.equalsIgnoreCase("Toffoli")) {
					radius = numberOfWires <= 5 ? 3 : 2;
					x = (4 * i + 5) * xDelta / 4;
					if (gate.yRegister) {
						y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
								* yDelta / 2 + gap + adjust;
						y1 = (2 * (numberOfWires - gate.qubits[1]) + 1)
								* yDelta / 2 + gap + adjust;
						y2 = (2 * (numberOfWires - gate.qubits[2]) + 1)
								* yDelta / 2 + gap + adjust;
					} else {
						y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
								* yDelta / 2 + adjust;
						y1 = (2 * (xRegisterSize - gate.qubits[1]) + 1)
								* yDelta / 2 + adjust;
						y2 = (2 * (xRegisterSize - gate.qubits[2]) + 1)
								* yDelta / 2 + adjust;
					}
					g.fillOval(x - radius, y0 - radius, 2 * radius, 2 * radius);
					g.fillOval(x - radius, y1 - radius, 2 * radius, 2 * radius);
					radius = numberOfWires <= 5 ? 6 : 4;
					if (y0 < y1 && y1 < y2) {
						g.drawLine(x, y0, x, y2 + radius);
					} else if (y0 > y1 && y1 > y2) {
						g.drawLine(x, y0, x, y2 - radius);
					} else {
						g.drawLine(x, y0, x, y1);
						g.drawLine(x, y1, x, y2);
					}
					g.drawOval(x - radius, y2 - radius, 2 * radius, 2 * radius);
				} else if (gate.name.equalsIgnoreCase("QFT")) {
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = xRegisterSize * yDelta + gap + adjust;
					} else {
						y0 = adjust - 1;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0, xDelta / 2, gateHeight - 1);
					g.setColor(Color.black);
					g.drawRect(x, y0, xDelta / 2, gateHeight - 1);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.drawString("F", x, y0 + gateHeight / 2 + 4);
				} else if (gate.name.equalsIgnoreCase("invQFT")) {
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = xRegisterSize * yDelta + gap + adjust;
					} else {
						y0 = adjust - 1;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0, xDelta / 2, gateHeight - 1);
					g.setColor(Color.black);
					g.drawRect(x, y0, xDelta / 2, gateHeight - 1);
					x = (4 * i + 5) * xDelta / 4 - fontHeight / 2;
					g.drawString("F-i", x, y0 + gateHeight / 2 + 4);
				} else if (gate.name.equalsIgnoreCase("function")) {
					setToolTipText("f(x)="
							+ gate.function.getFunction(0, false));
					gateHeight--;
					radius = numberOfWires <= 5 ? 3 : 2;
					x = (4 * i + 5) * xDelta / 4;
					for (int k = 0; k < xRegisterSize; k++) {
						y0 = (2 * (xRegisterSize - k) - 1) * yDelta / 2
								+ adjust;
						g.fillOval(x - radius, y0 - radius, 2 * radius,
								2 * radius);
					}
					y0 = yDelta / 2 + 1;
					y1 = xRegisterSize * yDelta + gap + adjust - 2;
					g.drawLine(x, y0, x, y1);
					x = (i + 1) * xDelta - 1;
					y0 = (numberOfWires - max) * yDelta + gap + adjust;
					g.setColor(Color.white);
					g.fillRect(x, y0, xDelta / 2 + 1, gateHeight - 1);
					g.setColor(Color.lightGray);
					g.drawRect(x, y0, xDelta / 2 + 1, gateHeight - 1);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.setColor(Color.black);
					g.drawString("f(x)", x - 3, y0 + gateHeight / 2 + 4);
				} else if (gate.name.equalsIgnoreCase("Rotation")) {
					gateHeight = 14;
					radius = numberOfWires <= 5 ? 3 : 2;
					x = (4 * i + 5) * xDelta / 4;
					int maxWire;
					if (gate.yRegister) {
						maxWire = numberOfWires;
					} else {
						maxWire = xRegisterSize;
					}
					for (int j = 0; j < gate.qubits.length - 1; j++) {
						y = (2 * (maxWire - gate.qubits[j]) + 1) * yDelta / 2
								+ adjust;
						if (gate.yRegister)
							y += yDelta / 2;
						g.fillOval(x - radius, y - radius, 2 * radius,
								2 * radius);
						if (j > 0)
							g.drawLine(x, y0 - radius, x, y - radius);
						y0 = y;
					}
					y = (2 * (maxWire - gate.qubits[gate.qubits.length - 1]) + 1)
							* yDelta / 2 + adjust;
					if (gate.yRegister)
						y += gap;
					if (gate.qubits.length > 1)
						g.drawLine(x, y0 - radius, x, y - radius);
					x = (i + 1) * xDelta;
					g.setColor(Color.white);
					g.fillRect(x, y - gateHeight / 2, xDelta / 2, gateHeight);
					g.setColor(Color.gray);
					g.drawRect(x, y - gateHeight / 2, xDelta / 2, gateHeight);
					// g.setColor( Color.blue );
					g.setColor(Color.red);
					x = (4 * i + 5) * xDelta / 4 - 12;
					g.drawString("R ( - )", x, y + 3);
					// g.setColor( Color.red );
					g.setColor(Color.blue);
					g.setFont(new java.awt.Font("Helvetica",
							java.awt.Font.PLAIN, 2 * fontHeight / 3));
					g.drawString(gate.axis, x + 7, y + 6);
					g.drawString("" + (char) 960, x + 14, y - 1);
					g.drawString("" + gate.phiAsPartOfPi, x + 15, y + 7);
					g.setFont(new java.awt.Font("Helvetica",
							java.awt.Font.PLAIN, fontSize));
					g.setColor(Color.black);
				} else if (gate.name.equalsIgnoreCase("Grover")) {
					gateHeight = xRegisterSize * yDelta;
					x = (i + 1) * xDelta;
					y0 = adjust - 1;
					g.setColor(Color.white);
					g.fillRect(x, y0, xDelta / 2, gateHeight - 1);
					g.setColor(Color.black);
					g.drawRect(x, y0, xDelta / 2, gateHeight - 1);
					x = (4 * i + 5) * xDelta / 4 - 3;
					g.drawString("G", x, y0 + gateHeight / 2 + 4);
					this.setToolTipText(bundle
							.getProperty("CircuitPanel.Grover.toolTipText")
							+ gate.qubits[0]);
				} else if (gate.name.equalsIgnoreCase("Measurement")) {
					gateHeight--;
					x = (i + 1) * xDelta;
					if (gate.yRegister) {
						y0 = (numberOfWires - max) * yDelta + gap + adjust;
					} else {
						y0 = (xRegisterSize - max) * yDelta + adjust - 1;
						max += yRegisterSize;
						min += yRegisterSize;
					}
					g.setColor(Color.white);
					g.fillRect(x, y0, xDelta / 2, gateHeight - 1);
					g.setColor(new Color(255, 0, 0));
					g.drawRect(x, y0, xDelta / 2, gateHeight);
					x = (4 * i + 5) * xDelta / 4 - 4;
					g.drawString("M", x, y0 + gateHeight / 2 + 4);
					g.setColor(Color.black);
				}
			} // loop over gates

			// separation line between x-register and y-register:
			if (xRegisterSize > 0 && yRegisterSize > 0) {
				g.setColor(new java.awt.Color(127, 127, 127));
				y = gap / 2 + xRegisterSize * yDelta + adjust - 1;
				g.drawLine(0, y, getWidth(), y);
				g.setColor(Color.black);
			}
		}
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	// End of variables declaration//GEN-END:variables

}
